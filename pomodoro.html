<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Device Pomodoro Timer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #2c3e50;
            color: white;
            transition: background-color 0.5s;
        }
        .timer-container {
            text-align: center;
            background: rgba(0, 0, 0, 0.2);
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }
        #status-message {
            font-size: 2em;
            margin-bottom: 20px;
        }
        #timer {
            font-size: 6em;
            margin: 10px 0;
            font-weight: bold;
        }
        .controls, .flexible-break-controls, .info-bar {
            margin-top: 20px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            font-size: 1em;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #3498db;
            color: white;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        #btn-start-pause {
            background-color: #2ecc71;
        }
        #btn-start-pause:hover {
            background-color: #27ae60;
        }
        .info-bar {
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 400px;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        .info-bar span {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }
        #settings-modal {
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
            display: none;
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #34495e;
            padding: 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 400px;
            color: white;
        }
        .modal-content label {
            display: block;
            margin-top: 10px;
            font-size: 1.1em;
        }
        .modal-content input {
            width: calc(100% - 22px);
            padding: 10px;
            margin-top: 5px;
            border-radius: 5px;
            border: 1px solid #7f8c8d;
            background-color: #2c3e50;
            color: white;
        }
        .modal-footer {
            margin-top: 20px;
            text-align: right;
        }
        .error-message {
            color: #e74c3c;
            font-weight: bold;
            margin-top: 10px;
        }
        .id-display {
            font-size: 0.8em;
            margin-top: 10px;
        }
    </style>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
</head>
<body>

    <div class="timer-container">
        <div class="info-bar">
            <span id="cycle-display">Cycle: 1/4</span>
            <span id="accumulated-display">Accumulated Break: 0 min</span>
        </div>
        <div id="status-message">Loading...</div>
        <div id="timer">00:00</div>

        <div class="controls">
            <button id="btn-start-pause">START</button>
            <button id="btn-skip">SKIP</button>
            <button id="btn-reset">RESET</button>
        </div>

        <div class="flexible-break-controls">
            <button id="btn-take-break" style="display: none;">TAKE ACCUMULATED BREAK</button>
            <button id="btn-return-focus" style="display: none;">RETURN TO FOCUS</button>
        </div>

        <div class="controls">
            <button id="btn-settings">SETTINGS</button>
        </div>

        <div class="id-display">
            <span id="connection-status">Connecting to Firebase...</span>
        </div>

        <div class="error-message" id="firebase-error" style="display: none;"></div>
    </div>

    <div id="settings-modal">
        <div class="modal-content">
            <h2>Settings</h2>
            <label for="focus-time">Focus Time (minutes):</label>
            <input type="number" id="focus-time" value="50">

            <label for="short-break-time">Short Break Time (minutes):</label>
            <input type="number" id="short-break-time" value="10">

            <label for="long-break-time">Long Break Time (minutes):</label>
            <input type="number" id="long-break-time" value="30">

            <label for="cycle-count">Cycles before Long Break:</label>
            <input type="number" id="cycle-count" value="4">

            <div class="modal-footer">
                <button id="btn-save-settings">Save</button>
                <button id="btn-close-settings">Close</button>
            </div>
        </div>
    </div>

    <script>
        // ====================================================================
        //  PASO IMPORTANTE: REEMPLAZA ESTO CON TUS CLAVES DE CONFIGURACIN DE FIREBASE 
        // ====================================================================
        const firebaseConfig = {

  apiKey: "AIzaSyB91A11J55B1NYAzEDYpMst1zli6Z-uuj4",

  authDomain: "pomodorosync-7f342.firebaseapp.com",

  databaseURL: "https://pomodorosync-7f342-default-rtdb.firebaseio.com",

  projectId: "pomodorosync-7f342",

  storageBucket: "pomodorosync-7f342.firebasestorage.app",

  messagingSenderId: "523175871116",

  appId: "1:523175871116:web:5c43cb66e4e01db215b1a9"

};
        // ====================================================================

        // Inicializar Firebase
        let db;
        try {
            const app = firebase.initializeApp(firebaseConfig);
            db = app.database();
            document.getElementById('connection-status').textContent = 'Your ID (for sync): Connected';
        } catch (error) {
            document.getElementById('connection-status').textContent = 'Your ID (for sync): Connection Failed';
            document.getElementById('firebase-error').style.display = 'block';
            document.getElementById('firebase-error').textContent = `Error: Firebase Init Failed. Check Console. (${error.message})`;
            console.error("Firebase Initialization Error: ", error);
            // Si Firebase falla, detenemos la ejecuci贸n para evitar m谩s errores.
            document.getElementById('btn-start-pause').disabled = true;
            document.getElementById('status-message').textContent = 'Initialization Failed';
            document.getElementById('timer').textContent = 'ERR';
            throw new Error("Initialization Failed"); // Detiene el script
        }
// Referencia al tiempo del servidor de Firebase
const serverTimeRef = db.ref('.info/serverTimeOffset');
let serverTimeOffset = 0;

serverTimeRef.on('value', (snap) => {
    serverTimeOffset = snap.val() || 0;
});

/**
 * Obtiene el tiempo actual, corrigiendo la diferencia con el servidor de Firebase.
 */
function getServerTime() {
    return Date.now() + serverTimeOffset;
}  
        // Referencia a la base de datos
        const dbRef = db.ref('pomodoroState');
        const dbSettingsRef = db.ref('pomodoroSettings');

        // Estado local (s贸lo para la interfaz y el intervalo)
        let localState = {
            timerInterval: null,
            isPaused: true,
            currentPhase: 'focus', // focus, break, longbreak, accumulated_break
            remainingTime: 0,
            accumulatedBreakTime: 0, // seconds
            currentCycle: 1,
            timePausedDuringFocus: 0 // Usado para el c谩lculo de reanudaci贸n
        };
        
        // Settings locales
        let settings = {
            focusTime: 50 * 60,
            shortBreakTime: 10 * 60,
            longBreakTime: 30 * 60,
            cycleCount: 4
        };

        // DOM Elements
        const timerDisplay = document.getElementById('timer');
        const statusMessage = document.getElementById('status-message');
        const startPauseBtn = document.getElementById('btn-start-pause');
        const skipBtn = document.getElementById('btn-skip');
        const takeBreakBtn = document.getElementById('btn-take-break');
        const returnFocusBtn = document.getElementById('btn-return-focus');
        const resetBtn = document.getElementById('btn-reset');
        const cycleDisplay = document.getElementById('cycle-display');
        const accumulatedDisplay = document.getElementById('accumulated-display');
        const settingsModal = document.getElementById('settings-modal');

        // Sonido
        const bell = new Audio('https://commondatastorage.googleapis.com/codeskulptor-assets/week7-bounce.m4a'); // Sonido simple

        // ====================================================================
        // LGICA DE ESTADO Y SINCRONIZACIN
        // ====================================================================

        /**
         * Inicializa la configuraci贸n de la base de datos o la recupera.
         */
        dbSettingsRef.once('value', snapshot => {
            if (snapshot.exists()) {
                const fetchedSettings = snapshot.val();
                settings.focusTime = fetchedSettings.focusTime * 60;
                settings.shortBreakTime = fetchedSettings.shortBreakTime * 60;
                settings.longBreakTime = fetchedSettings.longBreakTime * 60;
                settings.cycleCount = fetchedSettings.cycleCount;
            } else {
                dbSettingsRef.set({
                    focusTime: settings.focusTime / 60,
                    shortBreakTime: settings.shortBreakTime / 60,
                    longBreakTime: settings.longBreakTime / 60,
                    cycleCount: settings.cycleCount
                });
            }
            // Despu茅s de cargar settings, podemos cargar el estado principal
            loadInitialState();
        });


        /**
         * Maneja los cambios de estado de Firebase y actualiza la interfaz.
         * Esta es la clave de la sincronizaci贸n.
         */
        dbRef.on('value', (snapshot) => {
            const serverState = snapshot.val();
            if (!serverState) return;

            // Actualizar estado local con los datos del servidor
            localState.isPaused = serverState.isPaused;
            localState.currentPhase = serverState.currentPhase;
            localState.accumulatedBreakTime = serverState.accumulatedBreakTime;
            localState.currentCycle = serverState.currentCycle;
            
            // Si est谩 pausado, simplemente usamos el tiempo de pausa guardado
            if (serverState.isPaused) {
                localState.remainingTime = serverState.remainingTimeAtPause;
} else {
    // Si est谩 corriendo, calculamos el tiempo restante usando el tiempo del SERVIDOR
    const elapsedSeconds = (getServerTime() - serverState.startTime) / 1000;
    localState.remainingTime = Math.max(0, serverState.totalTimeForPhase - elapsedSeconds);
}
            updateUI();
            
            // Sincronizar el temporizador local
            clearInterval(localState.timerInterval);
            if (!localState.isPaused) {
                localState.timerInterval = setInterval(tick, 1000);
            }
        });


        /**
         * Carga el estado inicial si la base de datos est谩 vac铆a.
         */
        function loadInitialState() {
             dbRef.once('value', snapshot => {
                if (!snapshot.exists()) {
                    // Inicializar estado de la BD
                    const initialTotalTime = settings.focusTime;
                    dbRef.set({
                        isPaused: true,
                        currentPhase: 'focus',
                        remainingTimeAtPause: initialTotalTime, // En segundos
                        accumulatedBreakTime: 0, // En segundos
                        currentCycle: 1,
                        startTime: Date.now(),
                        totalTimeForPhase: initialTotalTime
                    });
                }
            });
        }


        /**
         * Env铆a los cambios de estado del temporizador a Firebase (llamado solo al hacer click).
         */
        function updateServerState(updates) {
            // Unificamos las actualizaciones con el estado actual del servidor para asegurar
            // que los datos clave (como totalTimeForPhase) se mantengan si no se especifican.
             dbRef.once('value', snapshot => {
                const serverState = snapshot.val() || {};
                const newState = { ...serverState, ...updates };
                dbRef.set(newState);
            });
        }

        // ====================================================================
        // LGICA DE TEMPORIZADOR
        // ====================================================================

        /**
         * Funci贸n que se ejecuta cada segundo localmente.
         * Cuando llega a 0, llama a endPhaseAndAutoStart.
         */
        function tick() {
            if (localState.isPaused) return;

            localState.remainingTime--;

            if (localState.remainingTime <= 0) {
                clearInterval(localState.timerInterval);
                bell.play();
                // Llamamos a la funci贸n de cambio de fase, que actualizar谩 el servidor
                endPhaseAndAutoStart();
            }
            updateUI();
        }

        /**
         * L贸gica de cambio de fase (Focus -> Break -> Focus...).
         * Actualiza el servidor para sincronizar a todos.
         */
        function endPhaseAndAutoStart() {
            let nextPhase, totalTime, nextCycle = localState.currentCycle;
            
            // 1. Fase actual termin贸. Calcular la siguiente.
            switch (localState.currentPhase) {
                case 'focus':
                    nextPhase = (nextCycle % settings.cycleCount === 0) ? 'longbreak' : 'break';
                    totalTime = (nextPhase === 'longbreak') ? settings.longBreakTime : settings.shortBreakTime;
                    // El ciclo se incrementa si estamos a punto de empezar un break.
                    nextCycle++; 
                    break;
                case 'break':
                case 'longbreak':
                    nextPhase = 'focus';
                    totalTime = settings.focusTime;
                    // El ciclo se ajust贸 en el paso anterior.
                    break;
                case 'accumulated_break':
                    // El tiempo restante no se acumula aqu铆. Volvemos al focus.
                    nextPhase = 'focus';
                    totalTime = settings.focusTime;
                    // Mantenemos el ciclo
                    break;
            }

            // 2. Aplicar auto-inicio al servidor
            updateServerState({
                isPaused: false, // Auto-Start
                currentPhase: nextPhase,
                startTime: Date.now(),
                totalTimeForPhase: totalTime,
                accumulatedBreakTime: localState.accumulatedBreakTime,
                currentCycle: nextPhase === 'focus' ? nextCycle - 1 : nextCycle, // Para mostrar el ciclo correcto
                remainingTimeAtPause: 0 // No aplica, pero lo reseteamos
            });
        }

        // ====================================================================
        // FUNCIONALIDADES PRINCIPALES (START/PAUSE/SKIP/RESET)
        // ====================================================================

        /**
         * Maneja el click en Start/Pause.
         */
        startPauseBtn.onclick = () => {
            if (localState.isPaused) {
// START
const totalTimeForPhase = getTotalTimeForCurrentPhase();
updateServerState({
    isPaused: false,
    startTime: firebase.database.ServerValue.TIMESTAMP, // 隆CRUCIAL PARA LA SINCRONIZACIN!
    totalTimeForPhase: totalTimeForPhase,
    remainingTimeAtPause: localState.remainingTime 
});
            } else {
                // PAUSE
                updateServerState({
                    isPaused: true,
                    remainingTimeAtPause: localState.remainingTime // Guardamos el tiempo restante
                });
            }
        };

        /**
         * Obtiene el tiempo total (en segundos) que deber铆a tener la fase actual.
         */
        function getTotalTimeForCurrentPhase() {
            switch (localState.currentPhase) {
                case 'focus':
                    return settings.focusTime;
                case 'break':
                    return settings.shortBreakTime;
                case 'longbreak':
                    return settings.longBreakTime;
                case 'accumulated_break':
                    // Durante un break acumulado, el tiempo total es la cantidad que estamos tomando.
                    // Para la reanudaci贸n del focus, usamos el tiempo restante del focus guardado.
                    return localState.remainingTime; 
                default:
                    return settings.focusTime;
            }
        }
        
        /**
         * Maneja el click en Skip.
         */
        skipBtn.onclick = () => {
            if (localState.currentPhase === 'focus') {
                // SKIP FOCUS: Pasa al siguiente break.
                // El tiempo de break NO se acumula en Skip Focus.
                bell.play();
                let nextPhase = (localState.currentCycle % settings.cycleCount === 0) ? 'longbreak' : 'break';
                let totalTime = (nextPhase === 'longbreak') ? settings.longBreakTime : settings.shortBreakTime;
                let nextCycle = localState.currentCycle + 1;

                updateServerState({
                    isPaused: false, // Auto-start
                    currentPhase: nextPhase,
                    startTime: Date.now(),
                    totalTimeForPhase: totalTime,
                    currentCycle: nextCycle
                });
            } else {
                // SKIP BREAK / LONG BREAK: Acumula el tiempo restante si es un break (normal o acumulado) y pasa a Focus.
                let accumulated = 0;
                let accumulatedTime = localState.accumulatedBreakTime;

                if (localState.currentPhase === 'break' || localState.currentPhase === 'longbreak') {
                    // Si se salta un break normal o largo, el tiempo se acumula.
                    accumulated = Math.ceil(localState.remainingTime);
                    accumulatedTime += accumulated;
                } else if (localState.currentPhase === 'accumulated_break') {
                    // Si se salta un break acumulado, el tiempo restante VUELVE a la acumulaci贸n.
                    accumulated = Math.ceil(localState.remainingTime);
                    accumulatedTime = localState.timePausedDuringFocus; // Resetear el tiempo que estaba pausado
                    
                    // No hay "skip" de accumulated break. Si la gente quiere volver al focus, usa RETURN. 
                    // Si llega a 0, termina el break.
                    
                    // Para seguir la intenci贸n del usuario, si est谩 en accumulated_break y presiona SKIP:
                    // 1. Devuelve el tiempo restante a la acumulaci贸n total
                    // 2. Reanuda el Focus desde donde se paus贸.
                    accumulatedTime = localState.accumulatedBreakTime + accumulated;
                    
                    updateServerState({
                        isPaused: false, // Auto-start
                        currentPhase: 'focus',
                        startTime: Date.now() - localState.timePausedDuringFocus * 1000, // Reanudar el focus desde donde estaba
                        totalTimeForPhase: settings.focusTime,
                        remainingTimeAtPause: 0, 
                        accumulatedBreakTime: accumulatedTime
                    });
                    
                    // La l贸gica de Skip en Accumulated Break es compleja. Por simplicidad, 
                    // si est谩 en accumulated_break, el bot贸n SKIP se oculta y solo aparece RETURN TO FOCUS.
                    // Aqu铆 llamaremos al mismo manejador que RETURN TO FOCUS.
                    return; 
                }

                bell.play();
                updateServerState({
                    isPaused: false, // Auto-start
                    currentPhase: 'focus',
                    startTime: Date.now(),
                    totalTimeForPhase: settings.focusTime,
                    accumulatedBreakTime: accumulatedTime,
                    remainingTimeAtPause: 0 // No aplica
                });
            }
        };

        /**
         * Maneja el click en Reset.
         */
        resetBtn.onclick = () => {
             if (confirm('Are you sure you want to reset the entire timer? All progress and accumulated break time will be lost.')) {
                // Reiniciar estado en la base de datos
                const initialTotalTime = settings.focusTime;
                updateServerState({
                    isPaused: true,
                    currentPhase: 'focus',
                    remainingTimeAtPause: initialTotalTime, 
                    accumulatedBreakTime: 0, 
                    currentCycle: 1,
                    startTime: Date.now(),
                    totalTimeForPhase: initialTotalTime
                });
                clearInterval(localState.timerInterval);
            }
        };


        // ====================================================================
        // LGICA DE BREAK FLEXIBLE
        // ====================================================================
        
        /**
         * Maneja el click para tomar el Break Acumulado durante un Focus.
         */
        takeBreakBtn.onclick = () => {
            if (localState.currentPhase === 'focus' && localState.accumulatedBreakTime > 0) {
                // 1. Pausar el Focus actual
                const timePausedDuringFocus = Math.ceil(localState.remainingTime);
                
                // 2. Cambiar a accumulated_break
                const breakTime = localState.accumulatedBreakTime;
                
                updateServerState({
                    isPaused: false, // Auto-start
                    currentPhase: 'accumulated_break',
                    startTime: Date.now(),
                    totalTimeForPhase: breakTime, // El tiempo total de la fase es el acumulado
                    accumulatedBreakTime: 0, // Se "vac铆a" la acumulaci贸n
                    timePausedDuringFocus: timePausedDuringFocus, // Guardamos cu谩nto quedaba del focus
                    remainingTimeAtPause: breakTime // Para la pausa
                });
            }
        };
        
        /**
         * Maneja el click para volver al Focus antes de que termine el Break Acumulado/Normal.
         */
        returnFocusBtn.onclick = () => {
            if (localState.currentPhase === 'accumulated_break') {
                // Volver al Focus, acumulando el tiempo restante.
                const remainingBreakTime = Math.ceil(localState.remainingTime);
                const reanudarFocusTime = localState.timePausedDuringFocus;
                
                updateServerState({
                    isPaused: false, // Auto-start
                    currentPhase: 'focus',
                    startTime: Date.now() - (settings.focusTime - reanudarFocusTime) * 1000, // Reanudar el focus desde el tiempo pausado
                    totalTimeForPhase: settings.focusTime,
                    accumulatedBreakTime: localState.accumulatedBreakTime + remainingBreakTime, // Acumula el tiempo restante
                    timePausedDuringFocus: 0,
                    remainingTimeAtPause: 0
                });
            } else if (localState.currentPhase === 'break' || localState.currentPhase === 'longbreak') {
                 // Volver al Focus, acumulando el tiempo restante del break normal/largo.
                const remainingBreakTime = Math.ceil(localState.remainingTime);
                
                updateServerState({
                    isPaused: false, // Auto-start
                    currentPhase: 'focus',
                    startTime: Date.now(),
                    totalTimeForPhase: settings.focusTime,
                    accumulatedBreakTime: localState.accumulatedBreakTime + remainingBreakTime, // Acumula el tiempo restante
                    remainingTimeAtPause: 0
                });
            }
        };

        // ====================================================================
        // MANEJO DE LA INTERFAZ (UI)
        // ====================================================================

        /**
         * Convierte segundos a formato MM:SS.
         */
        function formatTime(seconds) {
            const min = Math.floor(seconds / 60);
            const sec = Math.floor(seconds % 60);
            return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
        }
        
        /**
         * Muestra el estado actual en la interfaz.
         */
        function updateUI() {
            const { isPaused, currentPhase, remainingTime, accumulatedBreakTime, currentCycle } = localState;

            // 1. Timer y Estado
            timerDisplay.textContent = formatTime(remainingTime);
            startPauseBtn.textContent = isPaused ? 'START' : 'PAUSE';
            
            let statusText = '';
            let skipText = '';
            let bodyColor = '';

            switch (currentPhase) {
                case 'focus':
                    statusText = 'FOCUS TIME';
                    skipText = 'SKIP FOCUS';
                    bodyColor = '#c0392b';
                    break;
                case 'break':
                    statusText = 'SHORT BREAK';
                    skipText = 'SKIP BREAK';
                    bodyColor = '#27ae60';
                    break;
                case 'longbreak':
                    statusText = 'LONG BREAK';
                    skipText = 'SKIP LONG BREAK';
                    bodyColor = '#f39c12';
                    break;
                case 'accumulated_break':
                    statusText = 'FLEXIBLE BREAK';
                    skipText = ''; // Se oculta el skip en esta fase
                    bodyColor = '#3498db';
                    break;
            }

            statusMessage.textContent = statusText;
            document.body.style.backgroundColor = bodyColor;
            skipBtn.textContent = skipText;

            // 2. Controles flexibles
            takeBreakBtn.style.display = (currentPhase === 'focus' && accumulatedBreakTime > 0) ? 'inline-block' : 'none';
            returnFocusBtn.style.display = (currentPhase === 'accumulated_break' || currentPhase === 'break' || currentPhase === 'longbreak') ? 'inline-block' : 'none';
            
            // Si es un break normal/largo, el bot贸n Skip hace lo mismo que Return, pero con diferente texto.
            // Para evitar confusi贸n, solo ocultamos si es accumulated_break (donde solo tiene sentido RETURN).
            skipBtn.style.display = (currentPhase === 'accumulated_break') ? 'none' : 'inline-block';
            
            // 3. Info Bar
            let displayCycle = currentPhase === 'focus' ? currentCycle : currentCycle - 1;
            if (displayCycle === 0) displayCycle = 1; // Ajuste para el inicio
            cycleDisplay.textContent = `Cycle: ${displayCycle}/${settings.cycleCount}`;
            accumulatedDisplay.textContent = `Accumulated Break: ${Math.floor(accumulatedBreakTime / 60)} min`;
            
            // 4. Notificaciones
            updateNotification();
        }

        // ====================================================================
        // NOTIFICACIONES Y SONIDO
        // ====================================================================

        /**
         * Solicita permisos de notificaci贸n al cargar.
         */
        window.onload = () => {
            if (Notification.permission !== 'granted' && Notification.permission !== 'denied') {
                Notification.requestPermission();
            }
        };

        /**
         * Actualiza la notificaci贸n con el tiempo restante.
         */
        function updateNotification() {
            if (Notification.permission === 'granted') {
                const title = localState.currentPhase.toUpperCase().replace('_', ' ') + (localState.isPaused ? ' (Paused)' : ' (Running)');
                const body = `Time Left: ${formatTime(localState.remainingTime)}. Accumulated: ${Math.floor(localState.accumulatedBreakTime / 60)} min.`;

                // El enfoque aqu铆 es usar el 'tag' para reemplazar la notificaci贸n existente
                new Notification(title, { 
                    body: body,
                    icon: 'https://www.gstatic.com/images/branding/product/2x/timer_48dp.png', // Icono gen茅rico
                    tag: 'pomodoro-timer' 
                });
            }
        }

        // ====================================================================
        // MODAL DE CONFIGURACIN
        // ====================================================================

        document.getElementById('btn-settings').onclick = () => {
            // Cargar los valores actuales
            document.getElementById('focus-time').value = settings.focusTime / 60;
            document.getElementById('short-break-time').value = settings.shortBreakTime / 60;
            document.getElementById('long-break-time').value = settings.longBreakTime / 60;
            document.getElementById('cycle-count').value = settings.cycleCount;
            settingsModal.style.display = 'flex';
        };

        document.getElementById('btn-close-settings').onclick = () => {
            settingsModal.style.display = 'none';
        };

        document.getElementById('btn-save-settings').onclick = () => {
            // 1. Actualizar la BD de Settings
            const newSettings = {
                focusTime: parseInt(document.getElementById('focus-time').value),
                shortBreakTime: parseInt(document.getElementById('short-break-time').value),
                longBreakTime: parseInt(document.getElementById('long-break-time').value),
                cycleCount: parseInt(document.getElementById('cycle-count').value)
            };

            // Validaci贸n simple
            if (newSettings.focusTime <= 0 || newSettings.shortBreakTime <= 0 || newSettings.longBreakTime <= 0 || newSettings.cycleCount <= 0) {
                alert('All times and cycle count must be greater than 0.');
                return;
            }

            dbSettingsRef.set(newSettings).then(() => {
                // 2. Actualizar el estado local de settings
                settings.focusTime = newSettings.focusTime * 60;
                settings.shortBreakTime = newSettings.shortBreakTime * 60;
                settings.longBreakTime = newSettings.longBreakTime * 60;
                settings.cycleCount = newSettings.cycleCount;
                
                // 3. Reiniciar el temporizador para aplicar los nuevos tiempos
                resetBtn.click(); 
                settingsModal.style.display = 'none';
            }).catch(error => {
                alert('Error saving settings: ' + error.message);
            });
        };
        
        // Cierra el modal al hacer click fuera
        window.onclick = function(event) {
            if (event.target == settingsModal) {
                settingsModal.style.display = "none";
            }
        }

    </script>
</body>
</html>